-- -------------------------------------------------------------
-- 
-- File Name: C:\Users\D-Money\Desktop\Xilinx_stuff\GIT\Chilipepper_Labs\ChilipepperSupport\FIFO_demo\MATLAB\codegen\tx_fifo\hdlsrc\tx_fifo_fixpt.vhd
-- Created: 2014-05-05 19:59:33
-- 
-- Generated by MATLAB 8.3, MATLAB Coder 2.6 and HDL Coder 3.4
-- 
-- 
-- 
-- -------------------------------------------------------------
-- Rate and Clocking Details
-- -------------------------------------------------------------
-- Design base rate: 1
-- 
-- 
-- Clock Enable  Sample Time
-- -------------------------------------------------------------
-- ce_out        1
-- -------------------------------------------------------------
-- 
-- 
-- Output Signal                 Clock Enable  Sample Time
-- -------------------------------------------------------------
-- dout                          ce_out        1
-- bytes_available               ce_out        1
-- byte_received                 ce_out        1
-- empty                         ce_out        1
-- -------------------------------------------------------------
-- 
-- -------------------------------------------------------------


-- -------------------------------------------------------------
-- 
-- Module: tx_fifo_fixpt
-- Source Path: tx_fifo_fixpt
-- Hierarchy Level: 0
-- 
-- -------------------------------------------------------------
LIBRARY IEEE;
USE IEEE.std_logic_1164.ALL;
USE IEEE.numeric_std.ALL;

ENTITY tx_fifo_fixpt IS
  PORT( clk                               :   IN    std_logic;
        reset                             :   IN    std_logic;
        clk_enable                        :   IN    std_logic;
        reset_fifo                        :   IN    std_logic;  -- ufix1
        store_byte                        :   IN    std_logic;  -- ufix1
        byte_in                           :   IN    std_logic_vector(31 DOWNTO 0);  -- ufix32
        get_byte                          :   IN    std_logic;  -- ufix1
        ce_out                            :   OUT   std_logic;
        dout                              :   OUT   std_logic_vector(31 DOWNTO 0);  -- ufix32
        bytes_available                   :   OUT   std_logic_vector(31 DOWNTO 0);  -- ufix32
        byte_received                     :   OUT   std_logic;  -- ufix1
        empty                             :   OUT   std_logic  -- ufix1
        );
END tx_fifo_fixpt;


ARCHITECTURE rtl OF tx_fifo_fixpt IS

  -- Component Declarations
  COMPONENT fifo_ram
    PORT( clk                             :   IN    std_logic;
          enb                             :   IN    std_logic;
          wr_din                          :   IN    std_logic_vector(31 DOWNTO 0);  -- ufix32
          wr_addr                         :   IN    std_logic_vector(10 DOWNTO 0);  -- ufix11
          wr_en                           :   IN    std_logic;  -- ufix1
          rd_addr                         :   IN    std_logic_vector(10 DOWNTO 0);  -- ufix11
          rd_dout                         :   OUT   std_logic_vector(31 DOWNTO 0)  -- ufix32
          );
  END COMPONENT;

  -- Component Configuration Statements
  FOR ALL : fifo_ram
    USE ENTITY work.fifo_ram(rtl);

  -- Signals
  SIGNAL enb                              : std_logic;
  SIGNAL head_not_empty                   : std_logic;
  SIGNAL head_not_empty_1                 : std_logic;
  SIGNAL tmp                              : std_logic;
  SIGNAL tmp_1                            : std_logic;
  SIGNAL tmp_2                            : std_logic;
  SIGNAL head_not_empty_reg_head_not_empty : std_logic;
  SIGNAL tmp_3                            : std_logic;
  SIGNAL tmp_4                            : std_logic;
  SIGNAL head                             : unsigned(10 DOWNTO 0);  -- ufix11
  SIGNAL head_1                           : unsigned(10 DOWNTO 0);  -- ufix11
  SIGNAL full                             : std_logic;  -- ufix1
  SIGNAL full_1                           : std_logic;  -- ufix1
  SIGNAL tmp_5                            : std_logic;
  SIGNAL handshake                        : std_logic;  -- ufix1
  SIGNAL tmp_6                            : std_logic;
  SIGNAL handshake_1                      : std_logic;  -- ufix1
  SIGNAL handshake_2                      : std_logic;  -- ufix1
  SIGNAL tail                             : unsigned(10 DOWNTO 0);  -- ufix11
  SIGNAL tail_1                           : unsigned(10 DOWNTO 0);  -- ufix11
  SIGNAL empty_1                          : std_logic;  -- ufix1
  SIGNAL empty_2                          : std_logic;  -- ufix1
  SIGNAL tmp_7                            : std_logic;
  SIGNAL gb_handshake                     : std_logic;  -- ufix1
  SIGNAL tmp_8                            : std_logic;
  SIGNAL gb_handshake_1                   : std_logic;  -- ufix1
  SIGNAL gb_handshake_2                   : std_logic;  -- ufix1
  SIGNAL tmp_9                            : std_logic;
  SIGNAL tmp_10                           : std_logic;  -- ufix1
  SIGNAL tmp_11                           : std_logic;  -- ufix1
  SIGNAL tmp_12                           : std_logic;  -- ufix1
  SIGNAL gb_handshake_3                   : std_logic;  -- ufix1
  SIGNAL gb_handshake_reg_gb_handshake    : std_logic;  -- ufix1
  SIGNAL tmp_13                           : std_logic;  -- ufix1
  SIGNAL tmp_14                           : unsigned(10 DOWNTO 0);  -- ufix11
  SIGNAL tail_2                           : unsigned(10 DOWNTO 0);  -- ufix11
  SIGNAL tmp_15                           : std_logic;
  SIGNAL tmp_16                           : unsigned(10 DOWNTO 0);  -- ufix11
  SIGNAL tmp_17                           : std_logic;
  SIGNAL tmp_18                           : std_logic;  -- ufix1
  SIGNAL tmp_19                           : std_logic;  -- ufix1
  SIGNAL tmp_20                           : std_logic;  -- ufix1
  SIGNAL handshake_3                      : std_logic;  -- ufix1
  SIGNAL handshake_reg_handshake          : std_logic;  -- ufix1
  SIGNAL tmp_21                           : std_logic;  -- ufix1
  SIGNAL tmp_22                           : unsigned(10 DOWNTO 0);  -- ufix11
  SIGNAL head_2                           : unsigned(10 DOWNTO 0);  -- ufix11
  SIGNAL tmp_23                           : std_logic;
  SIGNAL tmp_24                           : unsigned(10 DOWNTO 0);  -- ufix11
  SIGNAL tmp_25                           : unsigned(10 DOWNTO 0);  -- ufix11
  SIGNAL head_3                           : unsigned(10 DOWNTO 0);  -- ufix11
  SIGNAL head_reg_head                    : unsigned(10 DOWNTO 0);  -- ufix11
  SIGNAL tmp_26                           : std_logic;
  SIGNAL tmp_27                           : std_logic;  -- ufix1
  SIGNAL tmp_28                           : unsigned(10 DOWNTO 0);  -- ufix11
  SIGNAL tail_3                           : unsigned(10 DOWNTO 0);  -- ufix11
  SIGNAL tail_reg_tail                    : unsigned(10 DOWNTO 0);  -- ufix11
  SIGNAL tmp_29                           : std_logic;
  SIGNAL tmp_30                           : std_logic;  -- ufix1
  SIGNAL tmp_31                           : std_logic;
  SIGNAL tmp_32                           : std_logic;
  SIGNAL byte_out                         : unsigned(31 DOWNTO 0);  -- ufix32
  SIGNAL tmp_33                           : std_logic;
  SIGNAL tmp_34                           : unsigned(31 DOWNTO 0);  -- ufix32
  SIGNAL byte_in_unsigned                 : unsigned(31 DOWNTO 0);  -- ufix32
  SIGNAL val                              : unsigned(31 DOWNTO 0);  -- ufix32
  SIGNAL tmp_35                           : signed(31 DOWNTO 0);  -- int32
  SIGNAL p48tmp_sub_cast                  : signed(31 DOWNTO 0);  -- int32
  SIGNAL addr                             : signed(31 DOWNTO 0);  -- int32
  SIGNAL tmp_36                           : unsigned(31 DOWNTO 0);  -- ufix32
  SIGNAL tmp_37                           : signed(31 DOWNTO 0);  -- int32
  SIGNAL indexLogic_fixptsig              : unsigned(10 DOWNTO 0);  -- ufix11
  SIGNAL tmp_38                           : signed(31 DOWNTO 0);  -- int32
  SIGNAL p44tmp_sub_cast                  : signed(31 DOWNTO 0);  -- int32
  SIGNAL addr_1                           : signed(31 DOWNTO 0);  -- int32
  SIGNAL fifo_ram_wrenb                   : std_logic;  -- ufix1
  SIGNAL tmp_39                           : signed(31 DOWNTO 0);  -- int32
  SIGNAL indexLogic_fixptsig_1            : unsigned(10 DOWNTO 0);  -- ufix11
  SIGNAL tmp_40                           : std_logic;
  SIGNAL byte_out_1                       : unsigned(31 DOWNTO 0);  -- ufix32
  SIGNAL tmp_41                           : unsigned(31 DOWNTO 0);  -- ufix32
  SIGNAL fifo                             : std_logic_vector(31 DOWNTO 0);  -- ufix32
  SIGNAL fifo_unsigned                    : unsigned(31 DOWNTO 0);  -- ufix32
  SIGNAL tmp_42                           : unsigned(31 DOWNTO 0);  -- ufix32
  SIGNAL tmp_43                           : unsigned(31 DOWNTO 0);  -- ufix32
  SIGNAL byte_out_2                       : unsigned(31 DOWNTO 0);  -- ufix32
  SIGNAL byte_out_reg_byte_out            : unsigned(31 DOWNTO 0);  -- ufix32
  SIGNAL tmp_44                           : unsigned(31 DOWNTO 0);  -- ufix32
  SIGNAL tmp_45                           : std_logic;
  SIGNAL tmp_46                           : unsigned(31 DOWNTO 0);  -- ufix32
  SIGNAL tmp_47                           : unsigned(31 DOWNTO 0);  -- ufix32
  SIGNAL tmp_48                           : unsigned(31 DOWNTO 0);  -- ufix32
  SIGNAL bytes_available_tmp              : unsigned(31 DOWNTO 0);  -- ufix32
  SIGNAL tmp_49                           : std_logic;
  SIGNAL byte_received_1                  : std_logic;  -- ufix1
  SIGNAL byte_received_2                  : std_logic;  -- ufix1
  SIGNAL tmp_50                           : std_logic;  -- ufix1
  SIGNAL byte_received_3                  : std_logic;  -- ufix1
  SIGNAL tmp_51                           : std_logic;  -- ufix1
  SIGNAL byte_received_4                  : std_logic;  -- ufix1
  SIGNAL empty_3                          : std_logic;  -- ufix1

BEGIN
  u_fifo_ram : fifo_ram
    PORT MAP( clk => clk,
              enb => clk_enable,
              wr_din => std_logic_vector(tmp_36),  -- ufix32
              wr_addr => std_logic_vector(indexLogic_fixptsig),  -- ufix11
              wr_en => fifo_ram_wrenb,  -- ufix1
              rd_addr => std_logic_vector(indexLogic_fixptsig_1),  -- ufix11
              rd_dout => fifo  -- ufix32
              );

  head_not_empty <= '1';

  enb <= clk_enable;

  tmp <= reset_fifo OR ( NOT head_not_empty_1);

  
  tmp_1 <= head_not_empty_1 WHEN tmp = '0' ELSE
      head_not_empty;

  tmp_2 <= tmp_1;

  head_not_empty_reg_process : PROCESS (clk, reset)
  BEGIN
    IF reset = '1' THEN
      head_not_empty_reg_head_not_empty <= '0';
    ELSIF clk'EVENT AND clk = '1' THEN
      IF enb = '1' THEN
        head_not_empty_reg_head_not_empty <= tmp_2;
      END IF;
    END IF;
  END PROCESS head_not_empty_reg_process;

  head_not_empty_1 <= head_not_empty_reg_head_not_empty;

  tmp_3 <= reset_fifo OR ( NOT head_not_empty_1);

  tmp_4 <= reset_fifo OR ( NOT head_not_empty_1);

  head <= to_unsigned(2#00000000001#, 11);

  head_1 <= to_unsigned(2#00000000001#, 11);

  full <= '0';

  full_1 <= '1';

  tmp_5 <= reset_fifo OR ( NOT head_not_empty_1);

  handshake <= '1';

  
  tmp_6 <= '1' WHEN store_byte = '0' ELSE
      '0';

  handshake_1 <= '0';

  handshake_2 <= '0';

  tail <= to_unsigned(2#00000000001#, 11);

  tail_1 <= to_unsigned(2#00000000010#, 11);

  empty_1 <= '0';

  empty_2 <= '1';

  --%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
  --                                                                          %
  --       Generated by MATLAB 8.3, MATLAB Coder 2.6 and HDL Coder 3.4        %
  --                                                                          %
  --%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
  --
  --  First In First Out (FIFO) structure.
  --  This FIFO stores integers.
  --  The FIFO is actually a circular buffer.
  --
  tmp_7 <= reset_fifo OR ( NOT head_not_empty_1);

  gb_handshake <= '1';

  
  tmp_8 <= '1' WHEN get_byte = '0' ELSE
      '0';

  gb_handshake_1 <= '0';

  gb_handshake_2 <= '0';

  
  tmp_11 <= tmp_10 WHEN tmp_9 = '0' ELSE
      gb_handshake;

  tmp_12 <= tmp_11;

  gb_handshake_reg_process : PROCESS (clk, reset)
  BEGIN
    IF reset = '1' THEN
      gb_handshake_reg_gb_handshake <= '0';
    ELSIF clk'EVENT AND clk = '1' THEN
      IF enb = '1' THEN
        gb_handshake_reg_gb_handshake <= tmp_12;
      END IF;
    END IF;
  END PROCESS gb_handshake_reg_process;

  gb_handshake_3 <= gb_handshake_reg_gb_handshake;

  
  tmp_13 <= gb_handshake_3 WHEN tmp_7 = '0' ELSE
      gb_handshake_1;

  
  tmp_10 <= tmp_13 WHEN tmp_8 = '0' ELSE
      gb_handshake_2;

  tail_2 <= tmp_14 + 1;

  
  tmp_15 <= '1' WHEN tail_2 = 1025 ELSE
      '0';

  
  tmp_16 <= tail_2 WHEN tmp_15 = '0' ELSE
      tail;

  
  tmp_19 <= tmp_18 WHEN tmp_17 = '0' ELSE
      handshake;

  tmp_20 <= tmp_19;

  handshake_reg_process : PROCESS (clk, reset)
  BEGIN
    IF reset = '1' THEN
      handshake_reg_handshake <= '0';
    ELSIF clk'EVENT AND clk = '1' THEN
      IF enb = '1' THEN
        handshake_reg_handshake <= tmp_20;
      END IF;
    END IF;
  END PROCESS handshake_reg_process;

  handshake_3 <= handshake_reg_handshake;

  
  tmp_21 <= handshake_3 WHEN tmp_5 = '0' ELSE
      handshake_1;

  
  tmp_18 <= tmp_21 WHEN tmp_6 = '0' ELSE
      handshake_2;

  head_2 <= tmp_22 + 1;

  
  tmp_23 <= '1' WHEN head_2 = 1025 ELSE
      '0';

  
  tmp_24 <= head_2 WHEN tmp_23 = '0' ELSE
      head;

  
  tmp_25 <= tmp_22 WHEN tmp_9 = '0' ELSE
      tmp_24;

  head_reg_process : PROCESS (clk, reset)
  BEGIN
    IF reset = '1' THEN
      head_reg_head <= to_unsigned(2#00000000000#, 11);
    ELSIF clk'EVENT AND clk = '1' THEN
      IF enb = '1' THEN
        head_reg_head <= tmp_25;
      END IF;
    END IF;
  END PROCESS head_reg_process;

  head_3 <= head_reg_head;

  
  tmp_22 <= head_3 WHEN tmp_4 = '0' ELSE
      head_1;

  
  tmp_26 <= '1' WHEN ((tmp_22 = 1) AND (tmp_14 = 1024)) OR ((resize(tmp_14, 12) + 1) = resize(tmp_22, 12)) ELSE
      '0';

  
  tmp_27 <= full WHEN tmp_26 = '0' ELSE
      full_1;

  --%%%%%%%%%%%%put%%%%%%%%%%%%%%%%%%%%%
  
  tmp_17 <= '1' WHEN ((store_byte /= '0') AND ( NOT (tmp_27 /= '0'))) AND (tmp_18 = '0') ELSE
      '0';

  
  tmp_28 <= tmp_14 WHEN tmp_17 = '0' ELSE
      tmp_16;

  tail_reg_process : PROCESS (clk, reset)
  BEGIN
    IF reset = '1' THEN
      tail_reg_tail <= to_unsigned(2#00000000000#, 11);
    ELSIF clk'EVENT AND clk = '1' THEN
      IF enb = '1' THEN
        tail_reg_tail <= tmp_28;
      END IF;
    END IF;
  END PROCESS tail_reg_process;

  tail_3 <= tail_reg_tail;

  
  tmp_14 <= tail_3 WHEN tmp_3 = '0' ELSE
      tail_1;

  -- Section for checking full and empty cases
  
  tmp_29 <= '1' WHEN ((tmp_14 = 1) AND (tmp_22 = 1024)) OR ((resize(tmp_22, 12) + 1) = resize(tmp_14, 12)) ELSE
      '0';

  
  tmp_30 <= empty_1 WHEN tmp_29 = '0' ELSE
      empty_2;

  --%%%%%%%%%%%%%get%%%%%%%%%%%%%%%%%%%%%
  
  tmp_9 <= '1' WHEN ((get_byte /= '0') AND ( NOT (tmp_30 /= '0'))) AND (tmp_10 = '0') ELSE
      '0';

  tmp_31 <= reset_fifo OR ( NOT head_not_empty_1);

  delayMatch_process : PROCESS (clk, reset)
  BEGIN
    IF reset = '1' THEN
      tmp_32 <= '0';
    ELSIF clk'EVENT AND clk = '1' THEN
      IF enb = '1' THEN
        tmp_32 <= tmp_31;
      END IF;
    END IF;
  END PROCESS delayMatch_process;


  byte_out <= to_unsigned(0, 32);

  delayMatch_1_process : PROCESS (clk, reset)
  BEGIN
    IF reset = '1' THEN
      tmp_33 <= '0';
    ELSIF clk'EVENT AND clk = '1' THEN
      IF enb = '1' THEN
        tmp_33 <= tmp_9;
      END IF;
    END IF;
  END PROCESS delayMatch_1_process;


  --HDL code generation from MATLAB function: tx_fifo_fixpt
  tmp_34 <= to_unsigned(0, 32);

  byte_in_unsigned <= unsigned(byte_in);

  val <= to_unsigned(0, 32);

  p48tmp_sub_cast <= signed(resize(tmp_14, 32));
  tmp_35 <= p48tmp_sub_cast - 1;

  addr <= to_signed(16#00000400#, 32);

  
  tmp_36 <= byte_in_unsigned WHEN tmp_17 = '1' ELSE
      val;

  
  tmp_37 <= tmp_35 WHEN tmp_17 = '1' ELSE
      addr;

  indexLogic_fixptsig <= unsigned(tmp_37(10 DOWNTO 0));

  p44tmp_sub_cast <= signed(resize(tmp_24, 32));
  tmp_38 <= p44tmp_sub_cast - 1;

  addr_1 <= to_signed(16#00000400#, 32);

  fifo_ram_wrenb <= '1';

  
  tmp_39 <= tmp_38 WHEN tmp_9 = '1' ELSE
      addr_1;

  indexLogic_fixptsig_1 <= unsigned(tmp_39(10 DOWNTO 0));

  delayMatch_2_process : PROCESS (clk, reset)
  BEGIN
    IF reset = '1' THEN
      tmp_40 <= '0';
    ELSIF clk'EVENT AND clk = '1' THEN
      IF enb = '1' THEN
        tmp_40 <= tmp_9;
      END IF;
    END IF;
  END PROCESS delayMatch_2_process;


  delayMatch_3_process : PROCESS (clk, reset)
  BEGIN
    IF reset = '1' THEN
      byte_out_1 <= to_unsigned(0, 32);
    ELSIF clk'EVENT AND clk = '1' THEN
      IF enb = '1' THEN
        byte_out_1 <= byte_out;
      END IF;
    END IF;
  END PROCESS delayMatch_3_process;


  delayMatch_4_process : PROCESS (clk, reset)
  BEGIN
    IF reset = '1' THEN
      tmp_41 <= to_unsigned(0, 32);
    ELSIF clk'EVENT AND clk = '1' THEN
      IF enb = '1' THEN
        tmp_41 <= tmp_34;
      END IF;
    END IF;
  END PROCESS delayMatch_4_process;


  fifo_unsigned <= unsigned(fifo);

  
  tmp_42 <= tmp_41 WHEN tmp_33 = '0' ELSE
      fifo_unsigned;

  byte_out_reg_process : PROCESS (clk, reset)
  BEGIN
    IF reset = '1' THEN
      byte_out_reg_byte_out <= to_unsigned(0, 32);
    ELSIF clk'EVENT AND clk = '1' THEN
      IF enb = '1' THEN
        byte_out_reg_byte_out <= tmp_43;
      END IF;
    END IF;
  END PROCESS byte_out_reg_process;

  byte_out_2 <= byte_out_reg_byte_out;

  
  tmp_44 <= byte_out_2 WHEN tmp_32 = '0' ELSE
      byte_out_1;

  
  tmp_43 <= tmp_44 WHEN tmp_40 = '0' ELSE
      tmp_42;

  dout <= std_logic_vector(tmp_43);

  -- Section for calculating num bytes in FIFO
  
  tmp_45 <= '1' WHEN tmp_25 < tmp_28 ELSE
      '0';

  tmp_46 <= resize(resize(resize(1024 - resize(tmp_25, 12), 13) + resize(tmp_28, 13), 14) - 1, 32);

  tmp_47 <= resize(resize(resize(tmp_28, 12) - resize(tmp_25, 12), 13) - 1, 32);

  
  tmp_48 <= tmp_46 WHEN tmp_45 = '0' ELSE
      tmp_47;

  delayMatch_5_process : PROCESS (clk, reset)
  BEGIN
    IF reset = '1' THEN
      bytes_available_tmp <= to_unsigned(0, 32);
    ELSIF clk'EVENT AND clk = '1' THEN
      IF enb = '1' THEN
        bytes_available_tmp <= tmp_48;
      END IF;
    END IF;
  END PROCESS delayMatch_5_process;


  bytes_available <= std_logic_vector(bytes_available_tmp);

  
  tmp_49 <= '1' WHEN tmp_18 = '1' ELSE
      '0';

  -- handshaking logic
  byte_received_1 <= '0';

  byte_received_2 <= '1';

  
  tmp_50 <= byte_received_1 WHEN tmp_49 = '0' ELSE
      byte_received_2;

  --HDL code generation from MATLAB function: tx_fifo_fixpt
  byte_received_3 <= '1';

  
  tmp_51 <= tmp_50 WHEN tmp_17 = '0' ELSE
      byte_received_3;

  byte_received_4 <= tmp_51;

  delayMatch_6_process : PROCESS (clk, reset)
  BEGIN
    IF reset = '1' THEN
      byte_received <= '0';
    ELSIF clk'EVENT AND clk = '1' THEN
      IF enb = '1' THEN
        byte_received <= byte_received_4;
      END IF;
    END IF;
  END PROCESS delayMatch_6_process;


  empty_3 <= tmp_30;

  delayMatch_7_process : PROCESS (clk, reset)
  BEGIN
    IF reset = '1' THEN
      empty <= '0';
    ELSIF clk'EVENT AND clk = '1' THEN
      IF enb = '1' THEN
        empty <= empty_3;
      END IF;
    END IF;
  END PROCESS delayMatch_7_process;


  ce_out <= clk_enable;

END rtl;

